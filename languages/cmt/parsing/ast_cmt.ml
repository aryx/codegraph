(* Yoann Padioleau
 *
 * Copyright (C) 2012, 2017 Facebook
 * Copyright (C) 2025 Yoann Padioleau
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation, with the
 * special exception on linking described in file license.txt.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file
 * license.txt for more details.
 *)

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* This is mostly a wrapper around the OCaml compiler-libs and its
 * typed OCaml tree but with a 'deriving show' to easily dump it.
 * 
 * Starting from ocaml 4.02, the library
 * https://github.com/ocaml-ppx/ocaml-migrate-parsetree
 * allows to migrate automatically AST from one version to another.
 * Unfortunately, the library only migrate Parsetree, not Typedtree, which
 * is the tree we are using here. Thus, I regularly need to update
 * the code under lang_cmt/ to handle the changes in the Typedtree and
 * thus .cmt format.
 * alt: 
 *  - using #ifdef to handle multiple versions (4.02, 4.03, ...) but
 *    this is tedious.
 *  - imitate what merlin is doing? They have the same issue, how do they solve
 *    it and track updates across many OCaml versions to the cmt format?
 *
 * history:
 *  - was just a thin wrapper over Cmt_format with a separate meta_ast_cmt.ml
 *    generated by ocamltarzan from a manual copy of the compiler-libs
 *    file in ast_cmt_stdlib.ml from OCaml 4.02 and adjusted then manually
 *    (and tediously) at each update of the language
 *  - use deriving to avoid the boilerplate updates
 *)


(***************************************************************************)
(* Intermediate modules *)
(***************************************************************************)

(* misc.mli *)
module Misc_ = struct
type modname = string
[@@deriving show]

end

(* types.mli *)
module Types_ = struct
type signature = Types.signature
let pp_signature _fmt _x = ()
end

(* typedtree.mli *)
module Typedtree_ = struct
type structure = Typedtree.structure
let pp_structure _fmt _x = ()

type signature = Typedtree.signature
let pp_signature _fmt _x = ()
end

(*****************************************************************************)
(* The final AST (Cmt) *)
(*****************************************************************************)

module Cmt_format_ = struct

type binary_annots = Cmt_format.binary_annots =
  | Packed of Types_.signature * string list
  | Implementation of Typedtree_.structure
  | Interface of Typedtree_.signature
  | Partial_implementation of binary_part array
  | Partial_interface of binary_part array

and binary_part = Cmt_format.binary_part [@opaque]

[@@deriving show]

type ast = Cmt_format.cmt_infos = {
  cmt_modname : Misc_.modname;
  cmt_annots : binary_annots;
  cmt_value_dependencies :
    (Types.value_description * Types.value_description) list [@opaque];
  cmt_comments : (string * Location.t) list [@opaque];
  cmt_args : string array;
  cmt_sourcefile : string option;
  cmt_builddir : string;
  cmt_loadpath : string list;
  cmt_source_digest : string option;
  cmt_initial_env : Env.t [@opaque];
  cmt_imports : Misc.crcs [@opaque];
  cmt_interface_digest : Digest.t option [@opaque];
  cmt_use_summaries : bool;
  cmt_uid_to_loc : Location.t Shape.Uid.Tbl.t [@opaque];
  cmt_impl_shape : Shape.t option [@opaque];
}
[@@deriving show]

end

type t = Cmt_format_.ast
[@@deriving show]
